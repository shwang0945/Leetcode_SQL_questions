1077. Project Employees III

My Answer:

SELECT p.project_id, p.employee_id
FROM (SELECT p.project_id, e.name, Max(e.experience_years) As years
FROM Project p , Employee e
WHERE p.employee_id = e.employee_id
GROUP BY p.project_id) a JOIN Project p ON a. project_id = p.project_id JOIN Employee e ON p.employee_id = e.employee_id
WHERE a.years = e.experience_years

Others:

MySQL

select p.project_id, p.employee_id
from Project p join Employee e
on p.employee_id = e.employee_id
where (p.project_id, e.experience_years) in (
    select a.project_id, max(b.experience_years)
    from Project a join Employee b
    on a.employee_id = b.employee_id
    group by a.project_id);
    
    
MSSQL - WINDOWS FUNCTION

select t.project_id, t.employee_id
from
    (select project_id,
    p.employee_id,
    rank() over(partition by project_id order by experience_years desc) as rank
    from Project p join Employee e
    on p.employee_id = e.employee_id) t
where t.rank = 1;



1126. Active Businesses

My Answer:

SELECT business_id
FROM Events e JOIN (SELECT event_type, Avg(occurences) As average_occurences
FROM Events
GROUP BY event_type) a ON e.event_type = a.event_type
WHERE e.occurences  > a.average_occurences
GROUP BY business_id HAVING COUNT(e.event_type) >1  

Others:

MS SQL - WINDOWSFUNCTION

select business_id from 
(
select  * , avg(occurences) over(partition by event_type ) as e_avg from 
events) a where occurences>e_avg
group by business_id having count(event_type)>1



534. Game Play Analysis III

My Answer: (MS SQL)

SELECT player_id,event_date, SUM(games_played)over(partition by player_id ORDER BY event_date) As games_played_so_far
FROM Activity 

MySQL
select a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far
from activity as a1
inner join activity as a2
on a1.event_date >= a2.event_date
and a1.player_id = a2.player_id
group by  a1.player_id, a1.event_date


177. Nth Highest Salary

MySQL:
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
    /* Write your T-SQL query statement below. */
    select COALESCE(SALARY,NULL) 
    FROM EMPLOYEE
    GROUP BY SALARY
    ORDER BY SALARY DESC
    OFFSET @N-1 ROWS FETCH FIRST 1 ROWS ONLY
);

**************************
The OFFSET clause specifies the number of rows to skip before starting to return rows from the query. The offset_row_count can be a constant, variable, or parameter that is greater or equal to zero.
The FETCH clause specifies the number of rows to return after the OFFSET clause has been processed. The offset_row_count can a constant, variable or scalar that is greater or equal to one.
The OFFSET clause is mandatory while the FETCH clause is optional. Also, the FIRST and NEXT are synonyms respectively so you can use them interchangeably. Similarly, you can use the FIRST and NEXT interchangeably.


